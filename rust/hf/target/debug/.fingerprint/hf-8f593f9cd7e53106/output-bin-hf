{"$message_type":"diagnostic","message":"the name `BasisSet` is defined multiple times","code":{"code":"E0255","explanation":"You can't import a value whose name is the same as another value defined in the\nmodule.\n\nErroneous code example:\n\n```compile_fail,E0255\nuse bar::foo; // error: an item named `foo` is already in scope\n\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {}\n```\n\nYou can use aliases in order to fix this error. Example:\n\n```\nuse bar::foo as bar_foo; // ok!\n\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {}\n```\n\nOr you can reference the item with its parent:\n\n```\nfn foo() {}\n\nmod bar {\n     pub fn foo() {}\n}\n\nfn main() {\n    bar::foo(); // we get the item by referring to its parent\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":210,"byte_end":229,"line_start":7,"line_end":7,"column_start":1,"column_end":20,"is_primary":true,"text":[{"text":"pub struct BasisSet {","highlight_start":1,"highlight_end":20}],"label":"`BasisSet` redefined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":33,"byte_end":52,"line_start":3,"line_end":3,"column_start":5,"column_end":24,"is_primary":false,"text":[{"text":"use basis_set::BasisSet;","highlight_start":5,"highlight_end":24}],"label":"previous import of the type `BasisSet` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`BasisSet` must be defined only once in the type namespace of this module","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"you can use `as` to change the binding name of the import","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":52,"byte_end":52,"line_start":3,"line_end":3,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"use basis_set::BasisSet;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":" as OtherBasisSet","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0255]\u001b[0m\u001b[1m: the name `BasisSet` is defined multiple times\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:7:1\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use basis_set::BasisSet;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------------\u001b[0m \u001b[1m\u001b[94mprevious import of the type `BasisSet` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct BasisSet {\n  \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`BasisSet` redefined here\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `BasisSet` must be defined only once in the type namespace of this module\n\u001b[1m\u001b[96mhelp\u001b[0m: you can use `as` to change the binding name of the import\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m3\u001b[0m \u001b[1m\u001b[94m| \u001b[0muse basis_set::BasisSet\u001b[92m as OtherBasisSet\u001b[0m;\n  \u001b[1m\u001b[94m|\u001b[0m                         \u001b[92m++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `serde`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":139,"byte_end":144,"line_start":6,"line_end":6,"column_start":17,"column_end":22,"is_primary":true,"text":[{"text":"#[derive(Debug, serde::Deserialize)] // Need to print full data deserialised from JSON","highlight_start":17,"highlight_end":22}],"label":"use of unresolved module or unlinked crate `serde`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `serde`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:6:17\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, serde::Deserialize)] // Need to print full data deserialised from JSON\n  \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `serde`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"only traits defined in the current crate can be implemented for types defined outside of the crate","code":{"code":"E0117","explanation":"Only traits defined in the current crate can be implemented for arbitrary types.\n\nErroneous code example:\n\n```compile_fail,E0117\nimpl Drop for u32 {}\n```\n\nThis error indicates a violation of one of Rust's orphan rules for trait\nimplementations. The rule prohibits any implementation of a foreign trait (a\ntrait defined in another crate) where\n\n - the type that is implementing the trait is foreign\n - all of the parameters being passed to the trait (if there are any) are also\n   foreign.\n\nTo avoid this kind of error, ensure that at least one local type is referenced\nby the `impl`:\n\n```\npub struct Foo; // you define your type in your crate\n\nimpl Drop for Foo { // and you can implement the trait on it!\n    // code of trait implementation here\n#   fn drop(&mut self) { }\n}\n\nimpl From<Foo> for i32 { // or you use a type from your crate as\n                         // a type parameter\n    fn from(i: Foo) -> i32 {\n        0\n    }\n}\n```\n\nAlternatively, define a trait locally and implement that instead:\n\n```\ntrait Bar {\n    fn get(&self) -> usize;\n}\n\nimpl Bar for u32 {\n    fn get(&self) -> usize { 0 }\n}\n```\n\nFor information on the design of the orphan rules, see [RFC 1023].\n\n[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":132,"byte_end":137,"line_start":6,"line_end":6,"column_start":10,"column_end":15,"is_primary":true,"text":[{"text":"#[derive(Debug, serde::Deserialize)] // Need to print full data deserialised from JSON","highlight_start":10,"highlight_end":15}],"label":"`basis_set::BasisSet` is not defined in the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":132,"byte_end":137,"line_start":6,"line_end":6,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, serde::Deserialize)] // Need to print full data deserialised from JSON","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/home/keiran/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    pub macro Debug($item:item) {","highlight_start":5,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"impl doesn't have any local type before any uncovered type parameters","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"define and implement a trait or new type instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0117]\u001b[0m\u001b[1m: only traits defined in the current crate can be implemented for types defined outside of the crate\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:6:10\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, serde::Deserialize)] // Need to print full data deserialised from JSON\n  \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91m`basis_set::BasisSet` is not defined in the current crate\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: impl doesn't have any local type before any uncovered type parameters\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: define and implement a trait or new type instead\n\n"}
{"$message_type":"diagnostic","message":"field `name` of struct `basis_set::BasisSet` is private","code":{"code":"E0616","explanation":"Attempted to access a private field on a struct.\n\nErroneous code example:\n\n```compile_fail,E0616\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // error: field `x` of struct `some_module::Foo` is private\n```\n\nIf you want to access this field, you have two options:\n\n1) Set the field public:\n\n```\nmod some_module {\n    pub struct Foo {\n        pub x: u32, // `x` is now public.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // ok!\n```\n\n2) Add a getter function:\n\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is still private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n\n        // We create the getter function here:\n        pub fn get_x(&self) -> &u32 { &self.x }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.get_x()); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":240,"byte_end":244,"line_start":8,"line_end":8,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"    pub name: String,","highlight_start":9,"highlight_end":13}],"label":"private field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0616]\u001b[0m\u001b[1m: field `name` of struct `basis_set::BasisSet` is private\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:8:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m8\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub name: String,\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mprivate field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"field `description` of struct `basis_set::BasisSet` is private","code":{"code":"E0616","explanation":"Attempted to access a private field on a struct.\n\nErroneous code example:\n\n```compile_fail,E0616\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // error: field `x` of struct `some_module::Foo` is private\n```\n\nIf you want to access this field, you have two options:\n\n1) Set the field public:\n\n```\nmod some_module {\n    pub struct Foo {\n        pub x: u32, // `x` is now public.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // ok!\n```\n\n2) Add a getter function:\n\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is still private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n\n        // We create the getter function here:\n        pub fn get_x(&self) -> &u32 { &self.x }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.get_x()); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":262,"byte_end":273,"line_start":9,"line_end":9,"column_start":9,"column_end":20,"is_primary":true,"text":[{"text":"    pub description: String,","highlight_start":9,"highlight_end":20}],"label":"private field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0616]\u001b[0m\u001b[1m: field `description` of struct `basis_set::BasisSet` is private\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:9:9\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub description: String,\n  \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mprivate field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"field `name` of struct `basis_set::BasisSet` is private","code":{"code":"E0616","explanation":"Attempted to access a private field on a struct.\n\nErroneous code example:\n\n```compile_fail,E0616\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // error: field `x` of struct `some_module::Foo` is private\n```\n\nIf you want to access this field, you have two options:\n\n1) Set the field public:\n\n```\nmod some_module {\n    pub struct Foo {\n        pub x: u32, // `x` is now public.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // ok!\n```\n\n2) Add a getter function:\n\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is still private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n\n        // We create the getter function here:\n        pub fn get_x(&self) -> &u32 { &self.x }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.get_x()); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":584,"byte_end":588,"line_start":19,"line_end":19,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"    println!(\"Loaded basis set: {} ({})\", basis_set.name, basis_set.description);","highlight_start":53,"highlight_end":57}],"label":"private field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0616]\u001b[0m\u001b[1m: field `name` of struct `basis_set::BasisSet` is private\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:19:53\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     println!(\"Loaded basis set: {} ({})\", basis_set.name, basis_set.description);\n   \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mprivate field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"field `description` of struct `basis_set::BasisSet` is private","code":{"code":"E0616","explanation":"Attempted to access a private field on a struct.\n\nErroneous code example:\n\n```compile_fail,E0616\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // error: field `x` of struct `some_module::Foo` is private\n```\n\nIf you want to access this field, you have two options:\n\n1) Set the field public:\n\n```\nmod some_module {\n    pub struct Foo {\n        pub x: u32, // `x` is now public.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.x); // ok!\n```\n\n2) Add a getter function:\n\n```\nmod some_module {\n    pub struct Foo {\n        x: u32, // So `x` is still private in here.\n    }\n\n    impl Foo {\n        pub fn new() -> Foo { Foo { x: 0 } }\n\n        // We create the getter function here:\n        pub fn get_x(&self) -> &u32 { &self.x }\n    }\n}\n\nlet f = some_module::Foo::new();\nprintln!(\"{}\", f.get_x()); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":600,"byte_end":611,"line_start":19,"line_end":19,"column_start":69,"column_end":80,"is_primary":true,"text":[{"text":"    println!(\"Loaded basis set: {} ({})\", basis_set.name, basis_set.description);","highlight_start":69,"highlight_end":80}],"label":"private field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0616]\u001b[0m\u001b[1m: field `description` of struct `basis_set::BasisSet` is private\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:19:69\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m19\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     println!(\"Loaded basis set: {} ({})\", basis_set.name, basis_set.description);\n   \u001b[1m\u001b[94m|\u001b[0m                                                                     \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mprivate field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 7 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 7 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0117, E0255, E0433, E0616.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0117, E0255, E0433, E0616.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0117`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0117`.\u001b[0m\n"}
